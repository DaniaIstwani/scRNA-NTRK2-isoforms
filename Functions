

# Filter samples based on minimum cell count

## Function to calculate overall proportions of each cell type in the entire dataset

calculate_overall_proportions <- function(data) {
  filtered_data <- data@meta.data %>%
    filter(Class %in% c("Astrocytes", "Neurons", "Oligos"))
  
  total_cell_count <- filtered_data %>%
    summarise(TotalCellCount = n()) %>%
    pull(TotalCellCount)
  
  cell_type_counts <- filtered_data %>%   # Calculate cell counts for each cell type
    group_by(Class) %>%
    summarise(CellCount = n(), .groups = 'drop')
  
  cell_type_counts <- cell_type_counts %>%   # Calculate proportions for each cell type
    mutate(Proportion = CellCount / total_cell_count)
  
  return(cell_type_counts)
}

## Function to get the proportion for a specific cell type
get_proportion <- function(proportions_df, cell_type) {
  proportion <- proportions_df %>%
    filter(Class == cell_type) %>%
    pull(Proportion)
  
  return(proportion)
}


## Function to filter cells by minimum count according to overall proportions

filter_samples_by_min_count <- function(data, min_total_count) {
  
  overall_proportions <- calculate_overall_proportions(data)
  
  # Scale minimum counts for each cell type based on overall proportions
  min_astrocyte_count <- min_total_count * get_proportion(overall_proportions, "Astrocytes")
  min_neuron_count <- min_total_count * get_proportion(overall_proportions, "Neurons")
  min_oligo_count <- min_total_count * get_proportion(overall_proportions, "Oligos")
  
  # Initialize a list to store SampleIDs that meet the criteria for each cell type
  valid_sample_ids <- list()
  
  # Check each cell type
  for (cell_type in c("Astrocytes", "Neurons", "Oligos")) {
    min_count <- switch(cell_type,
                        "Astrocytes" = min_astrocyte_count,
                        "Neurons" = min_neuron_count,
                        "Oligos" = min_oligo_count)
    
    ids <- data@meta.data %>%
      filter(Class == cell_type) %>%
      group_by(SampleID) %>%
      summarise(CellCount = n(), .groups = 'drop') %>%
      filter(CellCount >= min_count) %>%
      pull(SampleID)
    
    if (length(ids) == 0) {
      cat(sprintf("No samples have the defined minimum count for %s.\n", cell_type))
    } else {
      valid_sample_ids[[cell_type]] <- ids
    }
  }
  
  # Check if there are any SampleIDs that meet the criteria for all specified cell types
  if (length(valid_sample_ids) < 3) {
    cat("Some cell types did not meet the minimum cell count criteria.\n")
    return(NULL)
  }
  
  # Find common SampleIDs across all cell types
  samples_to_keep <- Reduce(intersect, valid_sample_ids)
  
  # Check if any samples meet the criteria
  if (length(samples_to_keep) == 0) {
    cat("No samples meet the minimum cell count across all specified cell types.\n")
    return(NULL)
  }
  
  # Subset the Seurat object to include only samples that meet the criteria
  seurat_subset <- subset(data, subset = SampleID %in% samples_to_keep & Class %in% c("Astrocytes", "Neurons", "Oligos"))
  
  # Verify if subset is empty
  if (seurat_subset@meta.data %>% nrow() == 0) {
    cat("The resulting subset of the data has no cells. Check the filtering criteria.\n")
    return(NULL)
  }
  
  # Cell Type per sample
  target_cell_counts_by_sample <- table(seurat_subset@meta.data$SampleID, seurat_subset@meta.data$Class)
  print(target_cell_counts_by_sample)
  
  # Convert the table to a data frame for plotting
  target_counts_df <- as.data.frame(target_cell_counts_by_sample)
  names(target_counts_df) <- c("Sample", "CellType", "Count")
  target_counts_df <- target_counts_df %>%
    filter(CellType %in% c("Astrocytes", "Oligos", "Neurons"))
  
  return(target_counts_df)
}


## function to plot the kept samples vs the cell count of each type

plot_cell_type_counts <- function(counts_df) {
  ggplot(counts_df, aes(x = Sample, y = Count, fill = CellType)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Cell Type Counts by Sample",
         x = "Sample",
         y = "Cell Count",
         fill = "Cell Type") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
}


subset_seurat_by_filtered_samples <- function(seurat_object, samples_to_keep) {
  if (length(samples_to_keep) > 0) {
    # Flatten the list of samples to keep
    flat_sample_ids <- unlist(lapply(samples_to_keep, names))
    flat_sample_ids <- unique(flat_sample_ids)
    
    # Ensure SampleID in seurat_object@meta.data is character type
    seurat_object@meta.data$SampleID <- as.character(seurat_object@meta.data$SampleID)
    
    # Subset the Seurat object to keep only the samples that meet the criteria
    seurat_filtered <- subset(seurat_object, cells = seurat_object@meta.data$SampleID %in% flat_sample_ids)
    
    return(seurat_filtered)
  } else {
    print("No samples meet the criteria for subsetting.")
    return(NULL)
  }
}



## Violin plot with a list of samples to keep

plot_gene_expression <- function(seurat_object, samples_to_keep, gene, cell_types_of_interest) {
  if (length(samples_to_keep) > 0) {
    # Subset the Seurat object to keep only the samples that meet the criteria
    seurat_filtered <- subset(seurat_object, subset = SampleID %in% samples_to_keep)
    
    # Create a violin plot for the filtered data
    plot <- VlnPlot(seurat_filtered, features = gene, group.by = 'Class', idents = cell_types_of_interest, sort = TRUE, pt.size = 0.1) + ylim(c(0,5)) + NoLegend()
    
    return(plot)
  } else {
    print("No samples meet the criteria for plotting.")
  }
}






#  Filter samples based on gene expression, returns samples




filter_samples_by_gene_expression <- function(seurat_object, gene, threshold, percentage_threshold, cell_types_of_interest) {
  summary_list <- list()
  
  # Ensure SampleID and Class are characters
  seurat_object@meta.data$SampleID <- as.character(seurat_object@meta.data$SampleID)
  seurat_object@meta.data$Class <- as.character(seurat_object@meta.data$Class)
  
  # Get unique sample IDs from the metadata
  sample_ids <- unique(seurat_object@meta.data$SampleID)
  
  # Loop over each sample ID
  for (sample_id in sample_ids) {
    results_per_cell_type <- list()
    
    # Filter metadata for the current sample ID
    sample_metadata <- seurat_object@meta.data %>% filter(SampleID == sample_id)
    
    # Fetch gene expression data for the current sample ID
    sample_expression_data <- FetchData(seurat_object, cells = rownames(sample_metadata), vars = gene)
    
    # Loop over each cell type of interest
    for (cell_type in cell_types_of_interest) {
      # Filter metadata for the current cell type
      cell_type_metadata <- sample_metadata %>% filter(Class == cell_type)
      
      # Ensure there are cells to avoid division by zero
      if (nrow(cell_type_metadata) > 0) {
        # Fetch gene expression data for the current cell type
        cell_type_expression_data <- sample_expression_data[rownames(cell_type_metadata), , drop = FALSE]
        
        # Calculate the proportion of cells where the gene's expression is above the threshold
        proportion_above_threshold <- sum(cell_type_expression_data[, gene] > threshold, na.rm = TRUE) / nrow(cell_type_expression_data) * 100
        
        # Add the result to the list for the cell type
        results_per_cell_type[[cell_type]] <- proportion_above_threshold
      }
    }
    
    # Check if any cell type meets the criteria and add to the summary list
    for (cell_type in cell_types_of_interest) {
      if (!is.null(results_per_cell_type[[cell_type]]) && results_per_cell_type[[cell_type]] >= percentage_threshold) {
        summary_list <- append(summary_list, list(data.frame(SampleID = sample_id, 
                                                             CellType = cell_type, 
                                                             ProportionAboveThreshold = results_per_cell_type[[cell_type]])))
      }
    }
  }
  
  # Combine the list of data frames into a single data frame
  summary_df <- do.call(rbind, summary_list)
  
  return(summary_df)
}
